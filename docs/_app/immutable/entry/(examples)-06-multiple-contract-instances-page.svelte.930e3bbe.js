var m=Object.defineProperty;var u=(a,e,t)=>e in a?m(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var c=(a,e,t)=>(u(a,typeof e!="symbol"?e+"":e,t),t);import{S as w,i as f,s as B,I as h,ac as I}from"../chunks/index.9fe14626.js";import{d as i,g as A,s as p}from"../chunks/store.96cf5894.js";import{d as C}from"../chunks/index.7100d5a9.js";const Q=`# Multiple Contract Instances

Instead of duplicating the code for the two contracts like in the previous example, we can write the code once and still deploy two separate instances. Each instance will have its own unique address.

We can do this by adding an argument to \`init()\`. When deploying the contract, we need to specify its init arguments. In this example we deploy twice, the first with the argument 1 and the second is deployed with 2.

We mentioned earlier that contract addresses on TON are [derived](https://docs.ton.org/learn/overviews/addresses#account-id) from the initial code of the contract (the compiled bytecode) and the initial data of the contract (the arguments of init).

Since we wrote the code once, the initial code is now identical. By adding an contructor argument, we've made the initial data different. This is why we're going to get two different addresses.`,v=`import "@stdlib/deploy";

// we're going to have multiple instances of this contract, each with a different seqno
contract Todo with Deployable {

    seqno: Int as uint64;
 
    // when deploying an instance, we must specify its index (sequence number)
    init(seqno: Int) {
        self.seqno = seqno;
    }
 
    // each instance can calculate the address of every other instance
    get fun addressOf(otherSeqno: Int): Address {
        let init: StateInit = initOf Todo(otherSeqno);
        return contractAddress(init);
    }
}`;function D(a){return e=>{let t=e;t.storeUint(2490013878,32),t.storeUint(a.queryId,64)}}function b(a){return e=>{e.storeInt(a.seqno,257)}}async function y(a){const e=i.Cell.fromBase64("te6ccgECEQEAAuUAART/APSkE/S88sgLAQIBYgIDApjQAdDTAwFxsKMB+kABINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiFRQUwNvBPhhAvhi2zxZ2zzy4ILI+EMBzH8BygABAcs/ye1UCgQCASAICQGKAZIwf+BwIddJwh+VMCDXCx/eghCUapi2uo6n0x8BghCUapi2uvLggdM/ATHIAYIQr/kPV1jLH8s/yfhCAXBt2zx/4DBwBQE6bW0ibrOZWyBu8tCAbyIBkTLiECRwAwSAQlAj2zwGAcrIcQHKAVAHAcoAcAHKAlAFINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiM8WUAP6AnABymgjbrORf5MkbrPilzMzAXABygDjDSFus5x/AcoAASBu8tCAAcyVMXABygDiyQH7AAcAmH8BygDIcAHKAHABygAkbrOdfwHKAAQgbvLQgFAEzJY0A3ABygDiJG6znX8BygAEIG7y0IBQBMyWNANwAcoA4nABygACfwHKAALJWMwCEb7x3tngDtnhjAoLAgEgDQ4ARu1E0NQB+GPSAAGU0z8BMeD4KNcLCoMJuvLgiYEBAdcAAQHRAYz4QwHbPHBZyHABywFzAcsBcAHLABLMzMn5AMhyAcsBcAHLABLKB8v/ydAg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIDABkAdD0BDBtAYFSNwGAEPQPb6Hy4IcBgVI3IgKAEPQXyAHI9ADJAcxwAcoAWAGBAQHPAMkAubu9GCcFzsPV0srnsehOw51kqFG2aCcJ3WNS0rZHyzItOvLf3xYjmCcCBVwBuAZ2OUzlg6rkclssOCcBvUne+VRZbxx1PT3gVZwyaCcJ2XTlqzTstzOg6WbZRm6KSAIBSA8QABGwr7tRNDSAAGAAdbJu40NWlwZnM6Ly9RbVBqS3d5QXF3U0JaWlpKZVRtVmF5dEdvajZhSG5hQ3dTdVdOR2hjVGoxVnQzgg"),t=i.Cell.fromBase64("te6cckECEwEAAu8AAQHAAQEFoKRvAgEU/wD0pBP0vPLICwMCAWINBAIBIAoFAgEgCQYCAUgIBwB1sm7jQ1aXBmczovL1FtUGpLd3lBcXdTQlpaWkplVG1WYXl0R29qNmFIbmFDd1N1V05HaGNUajFWdDOCAAEbCvu1E0NIAAYAC5u70YJwXOw9XSyuex6E7DnWSoUbZoJwndY1LStkfLMi068t/fFiOYJwIFXAG4BnY5TOWDquRyWyw4JwG9Sd75VFlvHHU9PeBVnDJoJwnZdOWrNOy3M6DpZtlGbopIAhG+8d7Z4A7Z4YwSCwGM+EMB2zxwWchwAcsBcwHLAXABywASzMzJ+QDIcgHLAXABywASygfL/8nQINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiAwAZAHQ9AQwbQGBUjcBgBD0D2+h8uCHAYFSNyICgBD0F8gByPQAyQHMcAHKAFgBgQEBzwDJApjQAdDTAwFxsKMB+kABINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiFRQUwNvBPhhAvhi2zxZ2zzy4ILI+EMBzH8BygABAcs/ye1UEg4BigGSMH/gcCHXScIflTAg1wsf3oIQlGqYtrqOp9MfAYIQlGqYtrry4IHTPwExyAGCEK/5D1dYyx/LP8n4QgFwbds8f+AwcA8BOm1tIm6zmVsgbvLQgG8iAZEy4hAkcAMEgEJQI9s8EAHKyHEBygFQBwHKAHABygJQBSDXSYEBC7ry4Igg1wsKIIEE/7ry0ImDCbry4IjPFlAD+gJwAcpoI26zkX+TJG6z4pczMwFwAcoA4w0hbrOcfwHKAAEgbvLQgAHMlTFwAcoA4skB+wARAJh/AcoAyHABygBwAcoAJG6znX8BygAEIG7y0IBQBMyWNANwAcoA4iRus51/AcoABCBu8tCAUATMljQDcAHKAOJwAcoAAn8BygACyVjMAEbtRNDUAfhj0gABlNM/ATHg+CjXCwqDCbry4ImBAQHXAAEB0eZKoEI=");let n=i.beginCell();n.storeRef(t),n.storeUint(0,1),b({$$type:"Todo_init_args",seqno:a})(n);const s=n.endCell();return{code:e,data:s}}const E={2:{message:"Stack undeflow"},3:{message:"Stack overflow"},4:{message:"Integer overflow"},5:{message:"Integer out of expected range"},6:{message:"Invalid opcode"},7:{message:"Type check error"},8:{message:"Cell overflow"},9:{message:"Cell underflow"},10:{message:"Dictionary error"},13:{message:"Out of gas error"},32:{message:"Method ID not found"},34:{message:"Action is invalid or not supported"},37:{message:"Not enough TON"},38:{message:"Not enough extra-currencies"},128:{message:"Null reference exception"},129:{message:"Invalid serialization prefix"},130:{message:"Invalid incoming message"},131:{message:"Constraints error"},132:{message:"Access denied"},133:{message:"Contract stopped"},134:{message:"Invalid argument"},135:{message:"Code of a contract was not found"},136:{message:"Invalid address"},137:{message:"Masterchain support is not enabled for this contract"}},k=[{name:"StateInit",header:null,fields:[{name:"code",type:{kind:"simple",type:"cell",optional:!1}},{name:"data",type:{kind:"simple",type:"cell",optional:!1}}]},{name:"Context",header:null,fields:[{name:"bounced",type:{kind:"simple",type:"bool",optional:!1}},{name:"sender",type:{kind:"simple",type:"address",optional:!1}},{name:"value",type:{kind:"simple",type:"int",optional:!1,format:257}},{name:"raw",type:{kind:"simple",type:"slice",optional:!1}}]},{name:"SendParameters",header:null,fields:[{name:"bounce",type:{kind:"simple",type:"bool",optional:!1}},{name:"to",type:{kind:"simple",type:"address",optional:!1}},{name:"value",type:{kind:"simple",type:"int",optional:!1,format:257}},{name:"mode",type:{kind:"simple",type:"int",optional:!1,format:257}},{name:"body",type:{kind:"simple",type:"cell",optional:!0}},{name:"code",type:{kind:"simple",type:"cell",optional:!0}},{name:"data",type:{kind:"simple",type:"cell",optional:!0}}]},{name:"Deploy",header:2490013878,fields:[{name:"queryId",type:{kind:"simple",type:"uint",optional:!1,format:64}}]},{name:"DeployOk",header:2952335191,fields:[{name:"queryId",type:{kind:"simple",type:"uint",optional:!1,format:64}}]},{name:"FactoryDeploy",header:1829761339,fields:[{name:"queryId",type:{kind:"simple",type:"uint",optional:!1,format:64}},{name:"cashback",type:{kind:"simple",type:"address",optional:!1}}]}],H=[{name:"addressOf",arguments:[{name:"otherSeqno",type:{kind:"simple",type:"int",optional:!1,format:257}}],returnType:{kind:"simple",type:"address",optional:!1}}],S=[{receiver:"internal",message:{kind:"typed",type:"Deploy"}}];class d{constructor(e,t){c(this,"address");c(this,"init");c(this,"abi",{types:[{name:"StateInit",header:null,fields:[]},{name:"Context",header:null,fields:[]},{name:"SendParameters",header:null,fields:[]},{name:"Deploy",header:2490013878,fields:[]},{name:"DeployOk",header:2952335191,fields:[]},{name:"FactoryDeploy",header:1829761339,fields:[]}],types:k,getters:H,receivers:S,errors:E});this.address=e,this.init=t}static async init(e){return await y(e)}static async fromInit(e){const t=await y(e),n=i.contractAddress(0,t);return new d(n,t)}static fromAddress(e){return new d(e)}async send(e,t,n,s){let o=null;if(s&&typeof s=="object"&&!(s instanceof i.Slice)&&s.$$type==="Deploy"&&(o=i.beginCell().store(D(s)).endCell()),o===null)throw new Error("Invalid message type");await e.internal(t,{...n,body:o})}async getAddressOf(e,t){let n=new i.TupleBuilder;return n.writeNumber(t),(await e.get("addressOf",n.build())).stack.readAddress()}}function L(a,e,t){let n;h(a,p,r=>t(3,n=r));let s,o;return I(p,n={markdown:Q,tactCode:v,deploy:async()=>{const r=await C.Blockchain.create(),l=await r.treasury("deployer");l.getSender(),s=r.openContract(await d.fromInit(1n)),o=r.openContract(await d.fromInit(2n));const g={[l.address.toString()]:"deployer",[s.address.toString()]:"Todo(1)",[o.address.toString()]:"Todo(2)"};return[[s,o],g,[await s.send(l.getSender(),{value:i.toNano(1)},{$$type:"Deploy",queryId:0n}),await o.send(l.getSender(),{value:i.toNano(1)},{$$type:"Deploy",queryId:0n})]]},messages:{},getters:{"addressOf(1)":async()=>await s.getAddressOf(1n),"addressOf(2)":async()=>await s.getAddressOf(2n)},prev:A(import.meta.url).prev,next:A(import.meta.url).next},n),[]}class N extends w{constructor(e){super(),f(this,e,L,null,B,{})}}export{N as default};
